	/**
	 *  Eurotronic Spirit TRV + DVC
	 *
	 *  Copyright 2020 Patrick Wogan
	 *
	 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
	 *  in compliance with the License. You may obtain a copy of the License at:
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
	 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
	 *  for the specific language governing permissions and limitations under the License.
	 *
	 *****************************Version 11*************************************
	 *
	 *
	 * Icons
	 * Lock - Icons made by Chanut from www.flaticon.com 
	 * Fire - Icons made by Good Warefrom www.flaticon.com
	 * Leaf - Icons made by Pixel perfect from www.flaticon.com
	 * Pipe, switch, growth, Snowflake, forbidden, levelup - Icons made by Freepik from ww.flaticon.com
	 * Refresh - Icons made by Google from ww.flaticon.com
	 * toggle, battery - Icons made by Those Icons from ww.flaticon.com
	 *
	 *
	 */
	metadata {
		definition (name: "Eurotronic Spirit TRV + DVC", namespace: "wogapat", author: "Patrick Wogan", cstHandler: true) {
			capability "Actuator"
			capability "Sensor"
			capability "Battery"
			capability "Lock"
			capability "Notification"
			capability "Switch"
			capability "Switch Level"
			capability "Temperature Measurement"
			capability "Thermostat Heating Setpoint"
			capability "Thermostat Mode"
			capability "Thermostat Operating State"
			capability "Configuration"
			capability "Health Check"
			capability "Refresh"

			command "autooff"
			command "booston"
			command "boostoff"
			command "ecoon"
			command "ecooff"
			command "froston"
			command "frostoff"
			command "temperatureUp"
			command "dvcon"
			command "dvcoff"
			command "temperatureDown"
			command "Poll"
			command "setCoolingSetpoint"

			attribute "minHeatingSetpoint", "number" // google / amazon
			attribute "maxHeatingSetpoint", "number" // google / amazon
			attribute "thermostatTemperatureSetpoint", "String"	//need for google
			//attribute "modeState", "string"

			

		fingerprint manufacturerId: "148"
		fingerprint mfr: "0148", prod: "0003", model: "0001", cc: "5E,55,98,9F", sec: "86,85,59,72,5A,73,75,31,26,40,43,80,70,71,6C,7A", role: "07", ff: "9200", ui: "9200", deviceJoinName: "Eurotronic Spirit TRV"
			
			// 0x80 = Battery v1
			// 0x70 = Configuration v1
			// 0x72 = Manufacturer Specific v1
			// 0x31 = Multilevel Sensor v5
			// 0x26 = MultiLevel Switch v1
			// 0x71 = Notification v8
			// 0x75 = Protection v2
			// 0x98 = Security v2
			// 0x40 = Thermostat Mode
			// 0x43 = Thermostat Setpoint v3
			// 0x86 = Version v1
		}


		simulator {
			// TODO: define status and reply messages here
		}
		
			multiAttributeTile(name:"temperature", type:"thermostat", width:6, height:4, canChangeIcon: true) {
				tileAttribute("device.temperature", key: "PRIMARY_CONTROL") {
					attributeState("temperature", label:'${currentValue}°',defaultState: true, backgroundColors:[
							// Celsius Color Range
							[value: 0, color: "#153591"],
							[value: 10, color: "#1e9cbb"],
							[value: 13, color: "#90d2a7"],
							[value: 17, color: "#44b621"],
							[value: 20, color: "#f1d801"],
							[value: 25, color: "#d04e00"],
							[value: 29, color: "#bc2323"],
							// Fahrenheit Color Range
							[value: 40, color: "#153591"],
							[value: 44, color: "#1e9cbb"],
							[value: 59, color: "#90d2a7"],
							[value: 74, color: "#44b621"],
							[value: 84, color: "#f1d801"],
							[value: 92, color: "#d04e00"],
							[value: 96, color: "#bc2323"]
						])
				}

				tileAttribute("device.nextHeatingSetpoint", key: "VALUE_CONTROL") {
					attributeState "VALUE_UP", action: "temperatureUp"
					attributeState "VALUE_DOWN", action: "temperatureDown"
				}

				tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
					attributeState "eco", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/leaf.png", backgroundColor:"#44b621"
					attributeState "heating", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/fire.png", backgroundColor:"#d04e00"
					attributeState "boost", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/levelup.png", backgroundColor:"#bc2323"
					attributeState "frost", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/snowflake.png", backgroundColor:"#1e9cbb"
					attributeState "Direct Valve Control", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/toggle.png", backgroundColor:"#d04e00"
				}

				//Thermostat Mode on main tile - classic
				tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") { 
					attributeState "eco", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/leaf.png", backgroundColor:"#44b621"
					attributeState "off", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/toggle.png", backgroundColor:"#44b621"
					attributeState "switched off", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/snowflake.png", backgroundColor:"#1e9cbb"
					attributeState "auto", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/fire.png", backgroundColor:"#d04e00"
					attributeState "heat", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/levelup.png", backgroundColor:"#bc2323"
				}

				tileAttribute("device.thermostatSetpoint", key: "HEATING_SETPOINT") {
					attributeState("thermostatSetpoint", label:'${currentValue}',  defaultState: true, backgroundColors:[
						// Celsius setpoint temp colour range
					[value: 0, color: "#b8c2de"],
					[value: 10, color: "#bbe1ea"],
					[value: 13, color: "#ddf1e4"],
					[value: 17, color: "#c6e9bc"],
					[value: 20, color: "#faf3b2"],
					[value: 25, color: "#f0c9b2"],
					[value: 29, color: "#eabdbd"],
						// Fahrenheit setpoint temp colour range
					[value: 40, color: "#b8c2de"],
					[value: 44, color: "#bbe1ea"],
					[value: 59, color: "#ddf1e4"],
					[value: 74, color: "#c6e9bc"],
					[value: 84, color: "#faf3b2"],
					[value: 95, color: "#f0c9b2"],
					[value: 96, color: "#eabdbd"]
				])
				}
			}
			
			//Battery
			valueTile("battery", "device.battery", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
					state ("battery", label:'${currentValue}%', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/battery.png", defaultState: true, backgroundColors:[
						[value: 100, color: "#44b621"],
						[value: 50, color: "#f1d801"],
						[value: 0, color: "#bc2323"],
					])
				}

			//thermostatOperatingState
			standardTile("operatingState", "device.thermostatOperatingState", width: 2, height: 2) { // duplication for feed (icons colours)
				state "eco", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/leaf.png", backgroundColor:"#44b621"
				state "heating", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/fire.png", backgroundColor:"#d04e00"
				state "boost", label:'${name}',  icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/levelup.png", backgroundColor:"#bc2323"
				state "frost", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/snowflake.png", backgroundColor:"#1e9cbb"
				state "Direct Valve Control", label:'${name}', icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/snowflake.png",  backgroundColor:"#d04e00"
			}

			valueTile("temp", "device.temperature", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
				state ("temp", label:'${currentValue}°', defaultState: true, backgroundColors:[
					[value: 0, color: "#153591"],
					[value: 10, color: "#1e9cbb"],
					[value: 13, color: "#90d2a7"],
					[value: 17, color: "#44b621"],
					[value: 20, color: "#f1d801"],
					[value: 25, color: "#d04e00"],
					[value: 29, color: "#bc2323"],
					// Fahrenheit Color Range
					[value: 40, color: "#153591"],
					[value: 44, color: "#1e9cbb"],
					[value: 59, color: "#90d2a7"],
					[value: 74, color: "#44b621"],
					[value: 84, color: "#f1d801"],
					[value: 92, color: "#d04e00"],
					[value: 96, color: "#bc2323"]
				])
			}
			
			valueTile("heatingSetpoint", "device.heatingSetpoint", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
				state("heatingSetpoint", label:'${currentValue}', defaultState: true, backgroundColors:[
					[value: 0, color: "#b8c2de"], 
					[value: 10, color: "#bbe1ea"],
					[value: 13, color: "#ddf1e4"],
					[value: 17, color: "#c6e9bc"], 
					[value: 20, color: "#faf3b2"],
					[value: 25, color: "#f0c9b2"],
					[value: 29, color: "#eabdbd"],
					// Fahrenheit setpoint temp colour range
					[value: 40, color: "#b8c2de"], 
					[value: 44, color: "#bbe1ea"], 
					[value: 59, color: "#ddf1e4"], 
					[value: 74, color: "#c6e9bc"],
					[value: 84, color: "#faf3b2"], 
					[value: 95, color: "#f0c9b2"], 
					[value: 96, color: "#eabdbd"]
				])
			}

			//Boost
			standardTile("boostMode", "device.thermostatMode", height: 2, width: 2, decoration: "flat") {
					state "default", label:'boost', action:"heat", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/levelup.png"
					state "heat", label:'auto', action:"auto", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/levelup.png", backgroundColor:"#bc2323"
				}


			//eco
			standardTile("ecoMode", "device.thermostatMode", height: 2, width: 2, decoration: "flat") {
				state "default", label: "eco", action:"ecoon", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/leaf.png"
				state "eco", label: "auto", action:"ecooff", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/leaf.png", backgroundColor:"#44b621"
			}

			//dvcMode
			standardTile("dvcMode", "device.thermostatMode", height: 2, width: 2, decoration: "flat") {
				state "default", label: "dvc", action:"dvcon", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/toggle.png"
				state "off", label: "auto", action:"dvcoff", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/switch.png", backgroundColor:"#44b621"
			}
			
			
			//frost
			standardTile("frost", "device.switch", height: 2, width: 2, decoration: "flat") {
				state "on", label:'frost', action:"off", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/snowflake.png"
				state "off", label:'auto', action:"on",  backgroundColor:"#1e9cbb", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/snowflake.png"
			}


			//lock
			standardTile("lock", "device.lock", width: 2, height: 2, decoration: "flat") {
				state "unlocked", label: "lock", action: "lock", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/unlocked.png"
				state "locked", label: "unlock", action: "unlock", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/locked.png"
			}
			
			//Configuration
			standardTile("configure", "device.configure", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
				state "default", label:'no changes', action:"configure", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/forbidden.png"
				state "configdue", label: "configure", action:"configure", icon:"https://raw.githubusercontent.com/bspranger/Xiaomi/master/images/ButtonPushed.png"
			}

			//Refresh
			standardTile("refresh", "device.refresh", inactiveLabel: false, height: 2, width: 2, decoration: "flat") {
				state "default", label:'refresh', action:"refresh.refresh", icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/refresh.png"
			}
			
			//Valve Level
			valueTile("trv", "device.level", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
				state "default", label: '${currentValue} %', defaultState: true, icon:"https://raw.githubusercontent.com/wogapat/ST-Eurotronic-Spirit/master/pipe.png"
			}
			
			//Set Valve Level
			controlTile("setValve", "device.level", "slider", height: 2, width: 2) {
				state "level", action:"switch level.setLevel"
			}
				
			main "temperature"
			details(["temperature", "boostMode", "ecoMode", "lock", "frost", "dvcMode", "battery", "configure", "refresh", "trv", "setValve",])
			}
		
		//Rates for Poll
		def rates = [:]
			rates << ["0" : "Off - Set temperature, valve & battery reports, if required"]
			rates << ["1" : "Refresh every minute (Not recommended)"]
			rates << ["5" : "Default - Refresh every 5 minutes"]
			rates << ["10" : "Refresh every 10 minutes"]
			rates << ["15" : "Refresh every 15 minutes"]
				
		//Thresholds for TRV Temp report
		def tempReportRates = [:] // // 0x00 Unsolicited Temperature reporting disabled 0x01 – 0x32 report if temperature changed by delta = 0,1°C … 5,0 °C default 0x05 (report on delta T = 0,5°C)
			tempReportRates << ["0" : "Off - Default"] // 0x00
			tempReportRates << ["1" : "Report 0.1 degree temperature change"] // 0x01
			tempReportRates << ["2" : "Report 0.2 degree temperature change"] // 0x02
			tempReportRates << ["5" : "Report 0.5 degree temperature change"] // 0x05
			tempReportRates << ["8" : "Report 0.8 degree temperature change"] // 0x08
			tempReportRates << ["10" : "Report 1.0 degree temperature change"] // 0x0A
			tempReportRates << ["15" : "Report 1.5 degree temperature change"] // 0x0E
			tempReportRates << ["20" : "Report 2.0 degree temperature change"] // 0x14
			tempReportRates << ["30" : "Report 3.0 degree temperature change"] // 0x1E
			tempReportRates << ["50" : "Report 5.0 degree temperature change"] // 0x32
		
		//Thresholds for TRV valve report
		def valveReportRates = [:] // 0x00 Unsolicited valve opening percentage reporting disabled 0x01-0x64 report if valve opening changed by delta = 1% … 100%  default 0x00
			valveReportRates << ["0" : "Off - Default"] // 0x00
			valveReportRates << ["1" : "Report 1% valve movement"] // 0x01
			valveReportRates << ["2" : "Report 2% valve movement"] // 0x02
			valveReportRates << ["5" : "Report 5% valve movement"] // 0x32
			valveReportRates << ["10" : "Report 10% valve movement"] // 0x0A
			valveReportRates << ["20" : "Report 20% valve movement"] // 0x14
			valveReportRates << ["30" : "Report 30% valve movement"] // 0x1E
			valveReportRates << ["50" : "Report 50% valve movement"] // 0x32
		
		//Settings Page
		preferences {
			//parameter 1
			input "LCDinvert", "enum", title: "Invert LCD", options: ["No", "Yes"], defaultValue: "Yes", required: false, displayDuringSetup: true
			//parameter 2
			input "LCDtimeout", "number", title: "LCD timeout (in secs)", description: "LCD off after: (5 - 30secs)", range: "5..30", displayDuringSetup: true
			//custom parameter
			input "ecoTemp", "number", title: "Eco heating setpoint", description: "Set eco heating setpoint : (8 - 28°C)", range: "8..28", displayDuringSetup: false
			//parameter 3
			input "backlight", "enum", title: "Enable backlight", options: ["No", "Yes"], defaultValue: "Yes", required: false, displayDuringSetup: true
			//parameter 4 
			input "battNotification", "enum", title: "Battery notification", options: ["Event only", "Once a day"], defaultValue: "Once a day", required: false, displayDuringSetup: true // 0x00 Battery status is only reported as a system notification (Notification CC)  0x01 Send battery status unsolicited once a day default: 0x01
			//parameter 5
			input "tempReport", "enum", title: "Temperature report threshold", description: "Set device thresholds to report temperature changes", options: tempReportRates, defaultValue: "0", required: false, displayDuringSetup: false
			//parameter 6
			input "valveReport", "enum", title: "Valve report threshold", description: "Set device thresholds to report valve changes", options: valveReportRates, defaultValue: "0", required: false, displayDuringSetup: false
			//parameter 7
			input "windowOpen", "enum", title: "Window open detection sensitivity",description: "Window open detection sensitivity", options: ["Disabled", "Low", "Medium", "High"] , defaultValue: "Medium", required: false, displayDuringSetup: false
			//parameter 8
			input "tempOffset", "number", title: "Temperature offset", description: "Set temperature offset : (-5 to +5°C)", range: "-5..5", displayDuringSetup: false
			// custom paramater
			input "tempMin", "number", title: "Min temperature recorded", description: "default 8 : (range 8 to 10°C)", range: "8..10", displayDuringSetup: false
			// custom parameter
			input "tempMax", "number", title: "Max temperature recorded", description: "default 28 : (range 25 to 28°C)", range: "25..28", displayDuringSetup: false
			// custom parameter
			input name: "refreshRate", type: "enum", title: "Refresh Rate", options: rates, description: "Select refresh rate", defaultValue: "5", required: false
		}
		
	// parse events into attributes
	def parse(String description) {
	  //log.debug "Parsing '${description}'"
		def result = []
		if (description.startsWith("Err 106")) {
			state.sec = 0
			result = createEvent(descriptionText: description, isStateChange: true)
		}
		else {
			def cmd = zwave.parse(description,[0x75:1])
			if (cmd) {
				result += zwaveEvent(cmd)
				//log.debug "Parsed ${cmd} to ${result.inspect()}"
			} else {
				log.debug "Non-parsed event: ${description}"
			}
		}
		return result
	}
		
	//Battery
	def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
		def map = [ name: "battery", unit: "%" ]
		if (cmd.batteryLevel == 0xFF) {  // Special value for low battery alert
			map.value = 1
			map.descriptionText = "${device.displayName} has a low battery"
			map.isStateChange = true
		} 
		else {
			map.value = cmd.batteryLevel
		}
		state.lastBatteryReportReceivedAt = new Date().time // Store time of last battery update so we don't ask every wakeup, see WakeUpNotification handler
		log.info "Report Received : $cmd"
		createEvent(map)
	}

	//Lock
	def zwaveEvent(physicalgraph.zwave.commands.protectionv1.ProtectionReport cmd) {
		def map
		if (cmd.payload == [0]) { //00 - unlocked
			map = [ name: "device.lock", value: "unlocked" ]
			
		}
		if (cmd.payload == [1]) { //01 - locked
			map = [ name: "device.lock", value: "locked" ]
		}
			 
		//log.debug "${cmd.payload}"
		createEvent(map)
		log.info "Protection State - ${map.value}"
	}

	//Valve
	def zwaveEvent(physicalgraph.zwave.commands.switchmultilevelv3.SwitchMultilevelReport cmd){
		log.info "Report Received : Valve open ${cmd.value}%"
		/*def valvePos

		if (cmd.value == 0 ) {
			valvePos = "Closed"
		} else {
		valvePos = "Open"
		}
		createEvent(name: "valve", value: "valvePos")
		*/
		
		def map
			map = [ name: "level"]  //unit: "%"]
			map.value = cmd.value
			createEvent (map)
		
	}

	//Temperature
	def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv5.SensorMultilevelReport cmd) {
		def map = [ value: cmd.scaledSensorValue.toString(), displayed: true ]
		def value = cmd.scaledSensorValue.toString()
		switch (cmd.sensorType) {
			case 1:
				map.name = "temperature"
				map.unit = cmd.scale == 1 ? "F" : "C"
				state.temperature = cmd.scaledSensorValue //.toString()
				break;
			/*case 2:
				map.name = "value"
				map.unit = cmd.scale == 1 ? "%" : ""
				break;*/
		}
		log.info "Report Received : $cmd"
		createEvent(map)
	}

	//Thermostat SetPoint
	def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd) { //	Parsed ThermostatSetpointReport(precision: 2, reserved01: 0, scale: 0, scaledValue: 21.00, setpointType: 1, size: 2, value: [8, 52])
		def event = []
		state.scale = cmd.scale	// So we can respond with same format later, see setHeatingSetpoint()
		state.precision = cmd.precision
		def radiatorSetPoint = cmd.scaledValue

		if (cmd.setpointType == 1 ) { //this is the standard heating setpoint //sendEvent
			event << createEvent(name: "nextHeatingSetpoint", value: radiatorSetPoint, unit: getTemperatureScale(), displayed: true)
			event << createEvent(name: "heatingSetpoint", value: radiatorSetPoint.toString(), unit: getTemperatureScale(), displayed: true)
			event << createEvent(name: "thermostatSetpoint", value: radiatorSetPoint.toString(), unit: getTemperatureScale(), displayed: false)
			event << createEvent(name: "thermostatTemperatureSetpoint", value: radiatorSetPoint.toString(), unit: "C", displayed: false)
		}
		if (cmd.setpointType == 11 ) { // this is eco heat setting on this device
			//event << createEvent(name: "coolingSetpoint", value: radiatorSetPoint.toString(), unit: getTemperatureScale(), displayed: false)
		}
		log.info "Report Received : ${cmd}"
		return event //List
	}

	//Basic Operating State
	def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd){
		def event = [ ]
		if (cmd.value == 255) { //255 - 0xFF = normal mode
			state.thermostatMode = "auto"
			state.thermostatOperatingState = "Heating"
			state.switch = "on"
		}
		if (cmd.value == 240){ //240 - 0xF0 = Boost
			state.thermostatMode = "boost"
			state.thermostatOperatingState = "Boost"
			state.switch = "on"
		}
		if (cmd.value == 0){ //0 - 0x00 = eco
			state.thermostatMode = "eco"
			state.thermostatOperatingState = "eco"
			state.switch = "on"
		}
		if (cmd.value == 15){ //15 - 0x0F = off
			state.thermostatMode = "Switched off"
			state.thermostatOperatingState = "Frost"
			state.switch = "off"
		}
		if (cmd.value == 254){     //254 - 0xFE = direct valve contol mode
			state.thermostatMode = "off"
			state.thermostatOperatingState = "Direct Valve Control"
			state.switch = "on"
		}

		event << createEvent(name: "thermostatMode", value: state.thermostatMode, displayed: true)
		event << createEvent(name: "thermostatOperatingState", value: state.thermostatOperatingState, displayed: true)
		event << createEvent(name: "switch", value: state.switch, displayed: true)
			
		log.info "Report Received : ${cmd}, ${state.thermostatMode}, ${state.thermostatOperatingState}"
		return event
	}

	//Thermostat Mode / Operating State
	def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport cmd ) {
		def event = []
		if (cmd.mode == 1){ //1 normal heat 0x01
			state.thermostatMode = "auto"
			state.thermostatOperatingState = "heating"
			state.switch = "on"
		}
		if (cmd.mode == 15){ //15 Boost 0x0F
			state.thermostatMode = "heat"
			state.thermostatOperatingState = "boost"
			state.switch = "on"
		}
		if (cmd.mode == 11){ //11 eco 11 0x0B
			state.thermostatMode = "eco"
			state.thermostatOperatingState = "eco"
			state.switch = "on"
		}
		if (cmd.mode == 0){ // 0 off 0x00
			state.thermostatMode = "switched off"
			state.thermostatOperatingState = "Frost"
			state.switch = "off"
		}
		if (cmd.mode == 31){ // 31 dvc 0xFE
			state.thermostatMode = "off"
			state.thermostatOperatingState = "Direct Valve Control"
			state.switch = "on"
		}
		event << createEvent(name: "thermostatMode", value: state.thermostatMode, displayed: true)
		event << createEvent(name: "thermostatOperatingState", value: state.thermostatOperatingState, displayed: true)
		event << createEvent(name: "switch", value: state.switch, displayed: true)
			
		log.info "Report Received : ${cmd}, ${state.thermostatMode}, ${state.thermostatOperatingState}"
		return event
	}

	//Supported Modes
	def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeSupportedReport cmd) {
		log.trace "$cmd"
		def supportedModes = []
		supportedModes << "off"
		supportedModes << "heat" 
		supportedModes << "cool" //eco //removed 4/2/19 == true)
		supportedModes << "auto" 
		//supportedModes << "emergency heat" //Boost
		log.debug "$supportedModes"
		state.supportedModes = supportedModes //.toString()
		log.info "Thermostat supported modes : ${state.supportedModes}"
			
		//updateDataValue("availableThermostatModes", supportedModes.toString())
		sendEvent(name: "supportedThermostatModes", value: supportedModes, displayed: false)
		log.info "Report Received : $cmd, Thermostat supported modes : $supportedModes"
	}

	/*def zwaveEvent(physicalgraph.zwave.commands.notificationv1.notificationReport cmd) {
		log.debug "Notification Report : $cmd"
	}*/



	def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
		def result = []
		if (cmd.nodeId.any { it == zwaveHubNodeId }) {
			result << sendEvent(descriptionText: "$device.displayName is associated in group ${cmd.groupingIdentifier}")
		} else if (cmd.groupingIdentifier == 1) {
			// We're not associated properly to group 1, set association
			result << sendEvent(descriptionText: "Associating $device.displayName in group ${cmd.groupingIdentifier}")
			result << response(zwave.associationV1.associationSet(groupingIdentifier:cmd.groupingIdentifier, nodeId:zwaveHubNodeId))
		}
		log.info "Report Received : $cmd"
		result
	}

	//
	def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation	 cmd) { // Devices that support the Security command class can send messages in an encrypted form; they arrive wrapped in a SecurityMessageEncapsulation command and must be unencapsulated
		log.debug "raw secEncap $cmd"
		state.sec = 1
		def encapsulatedCommand = cmd.encapsulatedCommand ([0x20: 1, 0x80: 1, 0x70: 1, 0x72: 1, 0x31: 5, 0x26: 3, 0x75: 1, 0x40: 2, 0x43: 2, 0x86: 1, 0x71: 3, 0x98: 2, 0x7A: 1 ]) 

		if (encapsulatedCommand) {
			return zwaveEvent(encapsulatedCommand)
		} else {
		log.warn "Unable to extract encapsulated cmd from $cmd"
		createEvent(descriptionText: cmd.toString())
		}
	}

	def zwaveEvent(physicalgraph.zwave.Command cmd) {
		def map = [ descriptionText: "${device.displayName}: ${cmd}" ]
		log.warn "mics zwave.Command - ${device.displayName} - $cmd"
		sendEvent(map)
	}


	def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
		if (cmd.manufacturerName) { updateDataValue("manufacturer", cmd.manufacturerName) }
		if (cmd.productTypeId) { updateDataValue("productTypeId", cmd.productTypeId.toString()) }
		if (cmd.productId) { updateDataValue("productId", cmd.productId.toString()) }
		if (cmd.manufacturerId){ updateDataValue("manufacturerId", cmd.manufacturerId.toString()) }
		log.info "Report Received : $cmd"
	}

	def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd ) {
		log.info "Report Received : $cmd"
	}


	//handle commands
	def temperatureUp() {
		//log.debug(device.currentValue("nextHeatingSetpoint").toBigDecimal())
		def nextTemp = device.currentValue("nextHeatingSetpoint").toBigDecimal() + 0.5
								// TODO: deal with Farenheit?
		if(nextTemp > 28) {		// It can't handle above 28, so don't allow it go above
			nextTemp = 28
		}
		sendEvent(name:"nextHeatingSetpoint", value: nextTemp, unit: getTemperatureScale(), displayed: false)	
		runIn (5, "buffSetpoint",[data: [value: nextTemp], overwrite: true])
	}

	def temperatureDown() {
		def nextTemp = device.currentValue("nextHeatingSetpoint").toBigDecimal() - 0.5
		if(nextTemp < 8) {		// It can't go below 8, so don't allow it
			nextTemp = 8
		}
		sendEvent(name:"nextHeatingSetpoint", value: nextTemp, unit: getTemperatureScale(), displayed: false)	
		runIn (5, "buffSetpoint",[data: [value: nextTemp], overwrite: true])
	}

	def buffSetpoint(data) {
		def key = "value"
		def nextTemp = data[key]
		//log.debug " buff nextTemp is $nextTemp"
		setHeatingSetpoint(nextTemp)
	}

	def setCoolingSetpoint(temp){
		/*log.debug "$temp"
		def nextTemp = $temp
		if(nextTemp < 8) {		// It can't go below 8, so don't allow it
			nextTemp = 8
		}
		if(nextTemp > 28) {		// It can't handle above 28, so don't allow it go above
			nextTemp = 28
		}
		log.debug "$nextTemp"
		log.trace "Set cooling setpoint temp of ${nextTemp}, sending temp value to setHeatingSetpoint"
		setHeatingSetpoint(nextTemp)*/
	}

	def setHeatingSetpoint(Double degrees) { //Double added
		def cmds = []
		def precision = state.precision ?: 2
		def deviceScale = state.scale ?: 0
		
		if (state.summer == "on" && degrees != 28){
			degrees = 28.0
			log.warn "temp changed to ${degrees} as in summer mode"
		}
		
		sendEvent(name:"nextHeatingSetpoint", value: degrees, unit: getTemperatureScale(), descriptionText: "Next heating setpoint is ${degrees}", offdisplayed: true, isStateChange:true)
		sendEvent(name:"nextHeatingSetpoint", value: degrees, unit: getTemperatureScale(), descriptionText: "Next heating setpoint is ${degrees}", displayed: true, isStateChange:true)
		
		cmds << zwave.thermostatSetpointV2.thermostatSetpointSet(precision: precision, scale: deviceScale, scaledValue: degrees, setpointType: 1)
		cmds << zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 1)
				
		log.trace "Setting Temp to ${degrees},  $cmds"
		secureSequence(cmds)
	}

	//lock
	def lock() {
		def cmds = []
		sendEvent(name: "lock", value: "locked", displayed: false)
		cmds << zwave.protectionV1.protectionSet(protectionState: 1)
		cmds << zwave.protectionV1.protectionGet()
		log.trace "lock $cmds" 
		secureSequence(cmds)
	}

	//unlock
	def unlock() {
		def cmds = []
		sendEvent(name: "lock", value: "unlocked", displayed: false)
		cmds << zwave.protectionV1.protectionSet(protectionState: 0)
		cmds << zwave.protectionV1.protectionGet()
		log.trace "unlock $cmds" 
		secureSequence (cmds)
	}

	/*
	* switch on/off turns frost on/off
	****Mode Commands**
	* Boost --> heat
	* auto --> This is the normal mode (Comfort)
	* cool --> ecoon
	* off --> dvcon
	*/

	def booston() {
		heat()
	}

	def boostoff(){
		auto()
	}

	def heat() { //Boost
		def cmds = []
		sendEvent(name: "thermostatMode", value: "heat", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 0x0F)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "heat On $cmds"
		secureSequence(cmds)
	}

	def auto(){ //Comfort
		def cmds = []
		sendEvent(name: "thermostatMode", value: "auto", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 1)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "auto $cmds" 
		secureSequence (cmds)
	}

	def off() {
		froston()
	}

	def on(){
		frostoff()
	}

	def froston(){ //taken from switchoff new app / frost tile classic
		def cmds = []
		sendEvent(name: "thermostatMode", value: "switched off", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 0)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "froston $cmds" 
		secureSequence(cmds)
	}
	 
	def frostoff(){
		auto()
	}
		
	def dvcon() { //taken from Mode off new app
		def cmds = []
		def currentLevel
		def maintLevel
		//log.trace device.currentValue("level")
			currentLevel = device.currentValue("level")
			maintLevel = currentLevel.toInteger()
			log.trace "${maintLevel}"

		sendEvent(name: "thermostatMode", value: "off", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 31)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		
		setLevel(maintLevel)
		//cmds << zwave.switchMultilevelV3.switchMultilevelSet(value: maintLevel)
			//cmds << zwave.switchMultilevelV3.switchMultilevelGet()
		log.trace "DVC On : $cmds"
		secureSequence(cmds)
	}
	  
	def dvcoff(){
		auto()
	}
	  
	def ecoon() { //cool
		def cmds = []
		sendEvent(name: "thermostatMode", value: "eco", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 11)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "Eco/Cool Heat $cmds"
		secureSequence(cmds)
	}
	 
	def ecooff(){
		auto()
	}
	  
	def setThermostatMode(String) {
		//log.debug "$String"
		def nextMode = String
		//log.debug "$nextMode"
		switch ("$nextMode") {
			case "heat":
				(booston())
				break
			case "auto":
				(auto())
				break
			case "cool":
				(ecoon())
				break
			case "off":
				(dvcon())
				break
			//log.debug "Can't do the command"
			}
	}
		
	//SetValve during DVC
		def setLevel(nextLevel) {
			def cmds = []

			sendEvent(name:"level", value: nextLevel, displayed: true, isStateChange:true)
			
			cmds << zwave.switchMultilevelV3.switchMultilevelSet(value: nextLevel)
			cmds << zwave.switchMultilevelV3.switchMultilevelGet()
					
			log.trace "Executing 'setLevel' : $cmds"
			secureSequence(cmds)
	}

	//Refresh (Momentary)
	def refresh() {
		log.trace "refresh"
		poll()
	}
	def daysToTime(days) {
			days*24*60*60*1000
	}
	def configure() {
		state.supportedModes = [off,heat, eco, Boost, dvc] // basic modes prior to details from device
		setDeviceLimits()
		//log.debug "tempReport : $tempReport"
		//log.debug "valveReport : $valveReport"
		//log.debug "refreshRate : $refreshRate"
		def cmds = []
		cmds << zwave.configurationV1.configurationSet(configurationValue:  LCDinvert == "Yes" ? [0x01] : [0x00], parameterNumber:1, size:1, scaledConfigurationValue:  LCDinvert == "Yes" ? 0x01 : 0x00)//,
		cmds << zwave.configurationV1.configurationSet(configurationValue: LCDtimeout == null ? [0] : [LCDtimeout], parameterNumber:2, size:1, scaledConfigurationValue: LCDtimeout == null ? 0 :  LCDtimeout)//,
		cmds << zwave.configurationV1.configurationSet(configurationValue:  backlight == "Yes" ? [0x01] : [0x00], parameterNumber:3, size:1, scaledConfigurationValue:  backlight == "Yes" ? 0x01 : 0x00)//,
		cmds << zwave.configurationV1.configurationSet(configurationValue:  battNotification == "Event only" ? [0x00] : [0x01], parameterNumber:4, size:1, scaledConfigurationValue:  battNotification == "Event only" ? 0x00 : 0x01) //,
		cmds << zwave.configurationV1.configurationSet(configurationValue:  tempReport == "1" ? [0x01] : tempReport == "2" ? [0x02] : tempReport == "5" ? [0x05] : tempReport == "8" ? [0x08] : tempReport == "10" ? [0x0A] : tempReport == "15" ? [0x0F] : tempReport == "20" ? [0x14] : tempReport == "30" ? [0x1E] : tempReport == "50" ? [0x32] : [0x00], parameterNumber:5, size:1, scaledConfigurationValue:  tempReport == "1" ? 0x01 : tempReport == "2" ? 0x02 : tempReport == "5" ? 0x05 : tempReport == "8" ? 0x08 : tempReport == "10" ? 0x0A : tempReport == "15" ? 0x0E : tempReport == "20" ? 0x14 : tempReport == "30" ? 0x1E : tempReport == "50" ? 0x32 : 0x00)//,
		cmds << zwave.configurationV1.configurationSet(configurationValue:  valveReport == "1" ? [0x01] : valveReport == "2" ? [0x02] : valveReport == "5" ? [0x05] : valveReport == "10" ? [0x0A] : valveReport == "20" ? [0x14] : valveReport == "30" ? [0x1E] : valveReport == "50" ? [0x32] : [0x00], parameterNumber:6, size:1, scaledConfigurationValue:  valveReport == "1" ? 0x01 : valveReport == "2" ? 0x02 : valveReport == "5" ? 0x05 : valveReport == "10" ? 0x0A : valveReport == "20" ? 0x14 : valveReport == "30" ? 0x1E : valveReport == "50" ? 0x32 : 0x00)//,
		cmds << zwave.configurationV1.configurationSet(configurationValue:  windowOpen == "Disabled" ? [0x00] : windowOpen == "Low" ? [0x01] : windowOpen == "High" ? [0x03] : [0x02], parameterNumber:7, size:1, scaledConfigurationValue: windowOpen == "Disabled" ? 0x00 : windowOpen == "Low" ? 0x01 : windowOpen == "High" ? 0x03 : 0x02)//,	
		cmds << zwave.configurationV1.configurationSet(configurationValue: tempOffset == null ? [0] : [tempOffset*10], parameterNumber:8, size:1, scaledConfigurationValue: tempOffset == null ? 0 : tempOffset*10)//,
		cmds << zwave.thermostatSetpointV1.thermostatSetpointSet(precision: 1, reserved01: 0, scale: 0, scaledValue: ecoTemp == null ? 18 : ecoTemp, setpointType: 11, size: 2, value: ecoTemp == null ? [0, 180] : [0, ecoTemp*10])//,
		cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType:1, scale:1)  // get temp
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		cmds << zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 0x01)
		cmds << zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 0x0B)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:1)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:2)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:3)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:4)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:5)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:6)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:7)
		cmds << zwave.configurationV1.configurationGet(parameterNumber:8)
		cmds << zwave.batteryV1.batteryGet()
		cmds << zwave.protectionV1.protectionGet()
		cmds << zwave.thermostatModeV2.thermostatModeSupportedGet()
		cmds << zwave.manufacturerSpecificV1.manufacturerSpecificGet()
		sendEvent(name: "configure") //value: "Configuration sent", displayed: false)   
		//log.trace "Configuration sent"
		secureSequence(cmds)
		}


	def updated() {
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
		if (!state.updatedLastRanAt || new Date().time >= state.updatedLastRanAt + 2000) {
			state.updatedLastRanAt = new Date().time
			unschedule(refresh)
			unschedule(poll)
			log.trace "Configuring settings"
			runIn (05, configure)
			sendEvent(name: "configure", value: "configdue", displayed: false)
			switch(refreshRate) {
			case "1":
				runEvery1Minute(poll)
				log.info "Refresh Scheduled for every minute"
				break
			case "15":
				runEvery15Minutes(poll)
				log.info "Refresh Scheduled for every 15 minutes"
				break
			case "10":
				runEvery10Minutes(poll)
				log.info "Refresh Scheduled for every 10 minutes"
				break
			case "5":
				runEvery5Minutes(poll)
				log.info "Refresh Scheduled for every 5 minutes"
				break
			case "0":
				log.info "Refresh off"}
	 
		}
		else {
			log.warn "update ran within the last 2 seconds"
		}
	}

	// PING is used by Device-Watch in attempt to reach the Device
	def ping() {
		refresh()
	}
	
	def poll() { // If you add the Polling capability to your device type, this command will be called approximately every 5 minutes to check the device's state
		//log.debug "poll"
		def cmds = []
			if (!state.lastBatteryReportReceivedAt || (new Date().time) - state.lastBatteryReportReceivedAt > daysToTime(1)) {
				log.trace "POLL - Asking for battery report as over 1 days since"
				cmds << zwave.batteryV1.batteryGet()
			}
			//once an hour ask for everything
			if (!state.extra || (new Date().time) - state.extra > (60*60000)) {			// mimutes * millseconds these settings shouldnt be needs as device should send response at time of update
				//cmds <<	zwave.thermostatModeV2.thermostatModeGet()	// get mode
				cmds <<	zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 11) 	// get eco/cool setpoint
				cmds <<	zwave.basicV1.basicGet()											// get mode (basic)	
				cmds <<	zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 1)	// get heating setpoint
				state.extra = new Date().time
			}
			cmds <<	zwave.sensorMultilevelV1.sensorMultilevelGet()	// get temp
			cmds << zwave.switchMultilevelV3.switchMultilevelGet()	// valve position
			cmds <<	zwave.thermostatModeV1.thermostatModeGet()		// get mode
			
			log.trace "POLL $cmds"
			secureSequence (cmds)
		}

	def setDeviceLimits() { // for google and amazon compatability
		sendEvent(name:"minHeatingSetpoint", value: settings.tempMin ?: 8, unit: "°C", displayed: false)
		sendEvent(name:"maxHeatingSetpoint", value: settings.tempMax ?: 28, unit: "°C", displayed: false)
		log.trace "setDeviceLimits - device max/min set"
	}	


	def secure(physicalgraph.zwave.Command cmd) {
		if (state.sec) {
			//log.debug "Seq secure - $cmd"
			zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
		} 
		else {
			//log.debug "Seq unsecure- $cmd"
			cmd.format()
		}
	}

	def secureSequence(commands, delay=1500) {
		//log.debug "SeSeq $commands"
		sendHubCommand(commands.collect{ response(secure(it)) }, delay)
	}	
								




















