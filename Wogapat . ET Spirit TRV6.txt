/**
 *  Eurotronic Spirit TRV
 *
 *  Copyright 2020 Patrick Wogan
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *Work in progress. Currently works well with classic. Working on new app compatibility. Currently seen as a lock in new app with some tiles functioning.
 *Many thanks to previous version from dougalAgain & mark_cockcroft. Most of the 'hard' work was done before me.
 *
 *******************************version6*****************************
 *
 *In this version Direct Valve Control added, with setLevel (changed from custom) with "Switch Level" capability command for valve control.
 *Ability to turn poll off and have TRV report on thresholds as per documentation
 *New app reporting lock / valve (Dimmer) status / battery / temperature / operating mode and / mode.
 *Removed 'summer' mode as for my purposes the 'off' setting is frost, according to documentation, which is fine for my needs.
 *Added "Actuator" & "Sensor" capabilities back in as these are needed by webCORE
 *
 *
 */
metadata {
	definition (name: "Eurotronic Spirit TRV", namespace: "Wogapat", author: "Patrick Wogan", cstHandler: true) {
		capability "Actuator"
		capability "Battery"
		capability "Configuration"
		capability "Lock"
        capability "Refresh"
		capability "Sensor"
		capability "Switch Level"
		capability "Temperature Measurement"
		capability "Thermostat Heating Setpoint"
		capability "Thermostat Mode"
        capability "Thermostat Operating State"
		capability "Notification"
		capability "Valve"
		
		command "temperatureUp"
		command "temperatureDown"

		fingerprint mfr: "0328", prod: "0003", model: "0001", deviceJoinName: "Eurotronic Spirit TRV"
	}


	simulator {
		// TODO: define status and reply messages here
	}

		tiles {
			multiAttributeTile(name:"temperature", type:"thermostat", width:6, height:4, canChangeIcon: true) {
				tileAttribute("device.temperature", key: "PRIMARY_CONTROL") {
					attributeState("temperature", label:'${currentValue}°',defaultState: true, backgroundColors:[
							// Celsius Color Range
							[value: 0, color: "#153591"],
							[value: 10, color: "#1e9cbb"],
							[value: 13, color: "#90d2a7"],
							[value: 17, color: "#44b621"],
							[value: 20, color: "#f1d801"],
							[value: 25, color: "#d04e00"],
							[value: 29, color: "#bc2323"],
							// Fahrenheit Color Range
							[value: 40, color: "#153591"],
							[value: 44, color: "#1e9cbb"],
							[value: 59, color: "#90d2a7"],
							[value: 74, color: "#44b621"],
							[value: 84, color: "#f1d801"],
							[value: 92, color: "#d04e00"],
							[value: 96, color: "#bc2323"]
						])
				}

				tileAttribute("device.nextHeatingSetpoint", key: "VALUE_CONTROL") {
					attributeState "VALUE_UP", action: "temperatureUp"
					attributeState "VALUE_DOWN", action: "temperatureDown"
											  
																			  
				}

				tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
					attributeState "eco heating", backgroundColor:"#44b621"
					attributeState "heating", backgroundColor:"#d04e00"
					attributeState "boost", backgroundColor:"#bc2323"
					attributeState "frost", backgroundColor:"#1e9cbb"
					attributeState "Direct Valve Control", backgroundColor:"#d04e00"
				}

				tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") { //need
					attributeState "boost", label:'${currentValue}' //, icon: "st.thermostat.heating", backgroundColor:"#bc2323"
					attributeState "eco", label:'${name}' //, icon: "st.nest.nest-leaf", backgroundColor:"#44b621"
					attributeState "dvc", label:'${name}' //, icon: "st.nest.nest-leaf", backgroundColor:"#44b621"
					attributeState "frost", label:'${name}' //, icon: "st.thermostat.heating-cooling-off", backgroundColor:"#1e9cbb"
					attributeState "comfort", label:'${name}' //, icon: "st.thermostat.heat"
				}

				tileAttribute("device.thermostatSetpoint", key: "HEATING_SETPOINT") {
					attributeState("thermostatSetpoint", label:'${currentValue}',  defaultState: true, backgroundColors:[
						// Celsius setpoint temp colour range
					[value: 0, color: "#b8c2de"],
					[value: 10, color: "#bbe1ea"],
					[value: 13, color: "#ddf1e4"],
					[value: 17, color: "#c6e9bc"],
					[value: 20, color: "#faf3b2"],
					[value: 25, color: "#f0c9b2"],
					[value: 29, color: "#eabdbd"],
						// Fahrenheit setpoint temp colour range
					[value: 40, color: "#b8c2de"],
					[value: 44, color: "#bbe1ea"],
					[value: 59, color: "#ddf1e4"],
					[value: 74, color: "#c6e9bc"],
					[value: 84, color: "#faf3b2"],
					[value: 95, color: "#f0c9b2"],
					[value: 96, color: "#eabdbd"]
				])
				}
			}
			valueTile("battery", "device.battery", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
				state ("battery", label:'${currentValue}%', icon:"https://raw.githubusercontent.com/bspranger/Xiaomi/master/images/XiaomiBattery.png", defaultState: true, backgroundColors:[
					[value: 100, color: "#44b621"],
					[value: 50, color: "#f1d801"],
					[value: 0, color: "#bc2323"],
				])
			}
			/*standardTile("operatingState", "device.thermostatOperatingState", width: 2, height: 2) { // duplication for feed (icons colours)
				state "eco", 	label:'${name}', backgroundColor:"#44b621"
				state "heating", 		label:'${name}', backgroundColor:"#e86d13",backgroundColor:"#d04e00"
				state "boost", label:'${name}', backgroundColor:"#bc2323"
				state "frost", 			label:'${name}', backgroundColor:"#1e9cbb"
				state "Direct Valve Control", 		label:'${name}', backgroundColor:"#d04e00",	backgroundColor:"#d04e00"
			}
			/*standardTile("switcher", "device.switch", height: 2, width: 2, decoration: "flat") {
				state "off", action:"on", label: "off", icon: "st.thermostat.heating-cooling-off", backgroundColor:"#ffffff"
				state "on", action:"off", label: "on", icon: "st.thermostat.heat", backgroundColor:"#00a0dc"
			}*/
			
			valueTile("temp", "device.temperature", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
				state ("temp", label:'${currentValue}°', defaultState: true, backgroundColors:[
				[value: 0, color: "#153591"],
				[value: 10, color: "#1e9cbb"],
				[value: 13, color: "#90d2a7"],
				[value: 17, color: "#44b621"],
				[value: 20, color: "#f1d801"],
				[value: 25, color: "#d04e00"],
				[value: 29, color: "#bc2323"],
				// Fahrenheit Color Range
							[value: 40, color: "#153591"],
							[value: 44, color: "#1e9cbb"],
							[value: 59, color: "#90d2a7"],
							[value: 74, color: "#44b621"],
							[value: 84, color: "#f1d801"],
							[value: 92, color: "#d04e00"],
							[value: 96, color: "#bc2323"]
				
			])
			}
			valueTile("heatingSetpoint", "device.heatingSetpoint", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
					state("heatingSetpoint", label:'${currentValue}', defaultState: true, backgroundColors:[
					[value: 0, color: "#b8c2de"], 
						[value: 10, color: "#bbe1ea"],
						[value: 13, color: "#ddf1e4"],
						[value: 17, color: "#c6e9bc"], 
						[value: 20, color: "#faf3b2"],
						[value: 25, color: "#f0c9b2"],
						[value: 29, color: "#eabdbd"],
						// Fahrenheit setpoint temp colour range
						[value: 40, color: "#b8c2de"], 
						[value: 44, color: "#bbe1ea"], 
						[value: 59, color: "#ddf1e4"], 
						[value: 74, color: "#c6e9bc"],
						[value: 84, color: "#faf3b2"], 
						[value: 95, color: "#f0c9b2"], 
						[value: 96, color: "#eabdbd"]
						])
				} 

			standardTile("refresh", "device.refresh", inactiveLabel: false, height: 2, width: 2,
						 decoration: "flat") {
					state "default", label:'refresh', action:"refresh"
			}
			
			standardTile("boostMode", "device.thermostatMode", height: 2, width: 2, decoration: "flat") {
				state "default", label:'boost', action:"boost"
				state "boost", label:'comfort', action:"boostoff", backgroundColor:"#bc2323"
			}

		standardTile("ecoMode", "device.thermostatMode", height: 2, width: 2, decoration: "flat") {
        	state "default", action:"ecoheat", label: "eco"
			//state "eco", action:"ecoheat", label: "Eco", icon: "st.nest.nest-leaf"
			state "eco", action:"ecooff", label: "eco"
		}

			standardTile("lock", "device.lock", width: 2, height: 2, decoration: "flat") {
            state "unlocked", label: "lock", action: "lock"
            state "locked", label: "unlock", action: "unlock",
                  backgroundColor:"#1e9cbb"
			}

		standardTile("turnOff", "device.thermostatMode", height: 2, width: 2, decoration: "flat") {
			state "default", label:'set frost', action:"off"
            state "frost", label:'comfort', action:"heat", backgroundColor:"#1e9cbb"
			
		}
			
			standardTile("configureAfterSecure", "device.configure", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
				state "default", label:'no changes', action:"configure"
				state "configdue", label: "configure", action:"configure", icon:"https://raw.githubusercontent.com/bspranger/Xiaomi/master/images/ButtonPushed.png"
			}
			standardTile("dvcMode", "device.thermostatMode", height: 2, width: 2, decoration: "flat") {
				state "default", action:"auto", label: "dvc"
				state "dvc", action:"heat", label: "comfort", backgroundColor:"#44b621"
			}
	   
		   valueTile("trv", "device.level", inactiveLabel: true, height: 2, width: 2, decoration: "flat") {
				state "trv", label: 'valve    ${currentValue} %', defaultState: true
			}
			controlTile("dimmer", "device.level", "slider", height: 2, width: 2, inactiveLabel: true) {
				state "trv"
        }
			
			main "temperature"
			details(["temperature", "boostMode", "ecoMode", "lock", "turnOff", "refresh", "battery", "configureAfterSecure", "dvcMode", "trv"])
		}
	
	def rates = [:]
		rates << ["0" : "Off - Set temperature, valve & battery reports, if required"]
		rates << ["1" : "Refresh every minute (Not recommended)"]
		rates << ["5" : "Default - Refresh every 5 minutes"]
		rates << ["10" : "Refresh every 10 minutes"]
		rates << ["15" : "Refresh every 15 minutes"]
			
	def tempReportRates = [:] // // 0x00 Unsolicited Temperature reporting disabled 0x01 – 0x32 report if temperature changed by delta = 0,1°C … 5,0 °C default 0x05 (report on delta T = 0,5°C)
		tempReportRates << ["0" : "Off - Default"] // 0x00
		tempReportRates << ["1" : "Report 0.1 degree temperature change"] // 0x01
		tempReportRates << ["2" : "Report 0.2 degree temperature change"] // 0x02
		tempReportRates << ["5" : "Report 0.5 degree temperature change"] // 0x05
		tempReportRates << ["8" : "Report 0.8 degree temperature change"] // 0x08
		tempReportRates << ["10" : "Report 1.0 degree temperature change"] // 0x0A
		tempReportRates << ["15" : "Report 1.5 degree temperature change"] // 0x0E
		tempReportRates << ["20" : "Report 2.0 degree temperature change"] // 0x14
		tempReportRates << ["30" : "Report 3.0 degree temperature change"] // 0x1E
		tempReportRates << ["50" : "Report 5.0 degree temperature change"] // 0x32
			
	def valveReportRates = [:] // 0x00 Unsolicited valve opening percentage reporting disabled 0x01-0x64 report if valve opening changed by delta = 1% … 100%  default 0x00
		valveReportRates << ["0" : "Off - Default"] // 0x00
		valveReportRates << ["1" : "Report 1% valve movement"] // 0x01
		valveReportRates << ["5" : "Report 5% valve movement"] // 0x32
		valveReportRates << ["10" : "Report 10% valve movement"] // 0x0A
		valveReportRates << ["20" : "Report 20% valve movement"] // 0x14
		valveReportRates << ["30" : "Report 30% valve movement"] // 0x1E
		valveReportRates << ["50" : "Report 50% valve movement"] // 0x32
						  
	preferences {
		//parameter 1
		input "LCDinvert", "enum", title: "Invert LCD", options: ["No", "Yes"], defaultValue: "No", required: false, displayDuringSetup: true
		//parameter 2
		input "LCDtimeout", "number", title: "LCD timeout (in secs)", description: "LCD off after: (5 - 30secs)", range: "5..30", displayDuringSetup: true
		//custom parameter
		input "ecoTemp", "number", title: "Eco heating setpoint", description: "Set eco heating setpoint : (8 - 28°C)", range: "8..28", displayDuringSetup: false
		//parameter 3
		input "backlight", "enum", title: "Enable backlight", options: ["No", "Yes"], defaultValue: "No", required: false, displayDuringSetup: true
		//parameter 4 
		input "battNotification", "enum", title: "Battery notification", options: ["Event only", "Once a day"], defaultValue: "Once a day", required: false, displayDuringSetup: true // 0x00 Battery status is only reported as a system notification (Notification CC)  0x01 Send battery status unsolicited once a day default: 0x01
		//parameter 5
		input "tempReport", "enum", title: "Temperature report threshold", description: "Set device thresholds to report temperature changes", options: tempReportRates, defaultValue: "0", required: false, displayDuringSetup: false
		//parameter 6
		input "valveReport", "enum", title: "Valve report threshold", description: "Set device thresholds to report valve changes", options: valveReportRates, defaultValue: "0", required: false, displayDuringSetup: false
		//parameter 7
		input "windowOpen", "enum", title: "Window open detection sensitivity",description: "Window open detection sensitivity", options: ["Disabled", "Low", "Medium", "High"] , defaultValue: "Medium", required: false, displayDuringSetup: false
		//parameter 8
		input "tempOffset", "number", title: "Temperature offset", description: "Set temperature offset : (-5 to +5°C)", range: "-5..5", displayDuringSetup: false
		// custom paramater
		input "tempMin", "number", title: "Min temperature recorded", description: "default 8 : (range 8 to 10°C)", range: "8..10", displayDuringSetup: false
		// custom parameter
		input "tempMax", "number", title: "Max temperature recorded", description: "default 28 : (range 25 to 28°C)", range: "25..28", displayDuringSetup: false
		// custome parameter
		input name: "refreshRate", type: "enum", title: "Refresh Rate", options: rates, description: "Select refresh rate", defaultValue: "5", required: false
		}
	}

// parse events into attributes
def parse(String description) {
  //log.debug "Parsing '${description}'"
	def result = []
	if (description.startsWith("Err 106")) {
		state.sec = 0
		result = createEvent(descriptionText: description, isStateChange: true)
	}
	else {
		def cmd = zwave.parse(description,[0x75:1])
		if (cmd) {
			result += zwaveEvent(cmd)
			//log.debug "Parsed ${cmd} to ${result.inspect()}"
		} else {
			log.debug "Non-parsed event: ${description}"
		}
	}
	return result
}



	//log.debug "Parsing '${description}'"
def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {  // Special value for low battery alert
		map.value = 1
		map.descriptionText = "${device.displayName} has a low battery"
		map.isStateChange = true
	} 
	else {
		map.value = cmd.batteryLevel
	}
	state.lastBatteryReportReceivedAt = new Date().time // Store time of last battery update so we don't ask every wakeup, see WakeUpNotification handler
	log.info "Report Received : $cmd"
	createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.protectionv1.ProtectionReport cmd) {
	def map
	if (cmd.payload == [0]) { //00 - unlocked
		map = [ name: "lock", value: "unlocked" ]
	}
	if (cmd.payload == [1]) { //01 - locked
		map = [ name: "lock", value: "locked" ]
	}
		 
	//log.debug "${cmd.payload}"
	createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.switchmultilevelv3.SwitchMultilevelReport cmd){
	log.info "Report Received : Valve open '${cmd.value}'%"
	def valvePos

	if (cmd.value == 0 ) {
		valvePos = "Closed"
	} else {
    valvePos = "Open"
    }
	createEvent(name: "valve", value: "valvePos")
	
	def map
		map = [ name: "level"]  //unit: "%"]
		map.value = cmd.value
		createEvent (map)
	
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv5.SensorMultilevelReport cmd) {
	def map = [ value: cmd.scaledSensorValue.toString(), displayed: true ]
	def value = cmd.scaledSensorValue.toString()
	switch (cmd.sensorType) {
		case 1:
			map.name = "temperature"
			map.unit = cmd.scale == 1 ? "F" : "C"
			state.temperature = cmd.scaledSensorValue //.toString()
			break;
		/*case 2:
			map.name = "value"
			map.unit = cmd.scale == 1 ? "%" : ""
			break;*/
	}
	log.info "Report Received : $cmd"
	createEvent(map)
}

	def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd) { //	Parsed ThermostatSetpointReport(precision: 2, reserved01: 0, scale: 0, scaledValue: 21.00, setpointType: 1, size: 2, value: [8, 52])
		def event = []
		state.scale = cmd.scale	// So we can respond with same format later, see setHeatingSetpoint()
		state.precision = cmd.precision
		def radiatorSetPoint = cmd.scaledValue

		if (cmd.setpointType == 1 ) { //this is the standard heating setpoint //sendEvent
			event << createEvent(name: "nextHeatingSetpoint", value: radiatorSetPoint, unit: getTemperatureScale(), displayed: true)
			event << createEvent(name: "heatingSetpoint", value: radiatorSetPoint.toString(), unit: getTemperatureScale(), displayed: true)
			event << createEvent(name: "thermostatSetpoint", value: radiatorSetPoint.toString(), unit: getTemperatureScale(), displayed: false)
			event << createEvent(name: "thermostatTemperatureSetpoint", value: radiatorSetPoint.toString(), unit: "C", displayed: false)
		}
		if (cmd.setpointType == 11 ) { // this is eco heat setting on this device
			//event << createEvent(name: "coolingSetpoint", value: radiatorSetPoint.toString(), unit: getTemperatureScale(), displayed: false)
		}
		log.info "Report Received : ${cmd}"
		return event //List
	}
	
	def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd){
		def event = [ ]
		if (cmd.value == 255) { //255 - 0xFF = normal mode
			state.thermostatMode = "comfort"
			state.thermostatOperatingState = "heating"
			state.switch = "on"
		}
		if (cmd.value == 240){ //240 - 0xF0 = boost
			state.thermostatMode = "boost"
			state.thermostatOperatingState = "boost"
			state.switch = "on"
		}
		if (cmd.value == 0){ //0 - 0x00 = eco
			state.thermostatMode = "eco"
			state.thermostatOperatingState = "eco heating"
			state.switch = "on"
		}
		if (cmd.value == 15){ //15 - 0x0F = off
			state.thermostatMode = "frost"
			state.thermostatOperatingState = "frost"
			state.switch = "off"
		}
		if (cmd.value == 254){     //254 - 0xFE = direct valve contol mode
			state.thermostatMode = "dvc"
			state.thermostatOperatingState = "Direct Valve Control"
			state.switch = "on"
		}

		event << createEvent(name: "thermostatMode", value: state.thermostatMode, displayed: true)
		event << createEvent(name: "thermostatOperatingState", value: state.thermostatOperatingState, displayed: true)
		event << createEvent(name: "switch", value: state.switch, displayed: false)
		
		log.info "Report Received : ${cmd}, ${state.thermostatMode}, ${state.thermostatOperatingState}"
		return event
	}

	def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport cmd ) {
		def event = []
		if (cmd.mode == 1){ //1 normal heat 0x01
			state.thermostatMode = "comfort"
			state.thermostatOperatingState = "heating"
			state.switch = "on"
		}
		if (cmd.mode == 15){ //15 boost 0x0F
			state.thermostatMode = "boost"
			state.thermostatOperatingState = "boost"
			state.switch = "on"
		}
		if (cmd.mode == 11){ //11 eco 11 0x0B
			state.thermostatMode = "eco"
			state.thermostatOperatingState = "eco heating"
			state.switch = "on"
		}
		if (cmd.mode == 0){ // 0 off 0x00
			state.thermostatMode = "frost"
			state.thermostatOperatingState = "frost"
			state.switch = "off"
		}
		if (cmd.mode == 31){ // 31 dvc 0xFE
			state.thermostatMode = "dvc"
			state.thermostatOperatingState = "Direct Valve Control"
			state.switch = "on"
		}
		event << createEvent(name: "thermostatMode", value: state.thermostatMode, displayed: true)
		event << createEvent(name: "thermostatOperatingState", value: state.thermostatOperatingState, displayed: true)
		event << createEvent(name: "switch", value: state.switch, displayed: false)
		
		log.info "Report Received : ${cmd}, ${state.thermostatMode}, ${state.thermostatOperatingState}"
		return event
	}


	def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeSupportedReport cmd) {
			//log.debug "$cmd"
		def supportedModes = []
			if(cmd.off) { supportedModes << "frost" }
			if(cmd.heat) { supportedModes << "heat" }
			if(cmd.auto) { supportedModes << "dvc" }
			if(cmd.auxiliaryemergencyHeat) { supportedModes << "boost" } //boost
			if (cmd.energySaveHeat) { supportedModes << "eco"} //eco //removed 4/2/19 == true)
		state.supportedModes = supportedModes //.toString()
		log.info "Thermostat supported modes : ${state.supportedModes}"
		
		//updateDataValue("availableThermostatModes", supportedModes.toString())
		sendEvent(name: "supportedThermostatModes", value: supportedModes, displayed: false)
		log.info "Report Received : $cmd, Thermostat supported modes : $supportedModes"
	}

	/*def zwaveEvent(physicalgraph.zwave.commands.notificationv1.notificationReport cmd) {
		log.debug "Notification Report : $cmd"
	}*/



	def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
			def result = []
			if (cmd.nodeId.any { it == zwaveHubNodeId }) {
					result << sendEvent(descriptionText: "$device.displayName is associated in group ${cmd.groupingIdentifier}")
			} else if (cmd.groupingIdentifier == 1) {
					// We're not associated properly to group 1, set association
					result << sendEvent(descriptionText: "Associating $device.displayName in group ${cmd.groupingIdentifier}")
					result << response(zwave.associationV1.associationSet(groupingIdentifier:cmd.groupingIdentifier, nodeId:zwaveHubNodeId))
			}
			log.info "Report Received : $cmd"
			result
	}

	def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) { // Devices that support the Security command class can send messages in an encrypted form; they arrive wrapped in a SecurityMessageEncapsulation command and must be unencapsulated
		log.debug "raw secEncap $cmd"
		state.sec = 1
		def encapsulatedCommand = cmd.encapsulatedCommand ([0x20: 1, 0x80: 1, 0x70: 1, 0x72: 1, 0x31: 5, 0x26: 3, 0x75: 1, 0x40: 2, 0x43: 2, 0x86: 1, 0x71: 3, 0x98: 2, 0x7A: 1 ]) 

		if (encapsulatedCommand) {
			return zwaveEvent(encapsulatedCommand)
		} else {
			log.warn "Unable to extract encapsulated cmd from $cmd"
			createEvent(descriptionText: cmd.toString())
		}
	}

	def zwaveEvent(physicalgraph.zwave.Command cmd) {
		def map = [ descriptionText: "${device.displayName}: ${cmd}" ]
		log.warn "mics zwave.Command - ${device.displayName} - $cmd"
		sendEvent(map)
	}


	def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
		if (cmd.manufacturerName) { updateDataValue("manufacturer", cmd.manufacturerName) }
		if (cmd.productTypeId) { updateDataValue("productTypeId", cmd.productTypeId.toString()) }
		if (cmd.productId) { updateDataValue("productId", cmd.productId.toString()) }
		if (cmd.manufacturerId){ updateDataValue("manufacturerId", cmd.manufacturerId.toString()) }
		log.info "Report Received : $cmd"
	}

	def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd ) {
		log.info "Report Received : $cmd"
	}

// handle commands
	// handle commands
	def lock() {
		def cmds = []
		sendEvent(name: "lock", value: "locked", displayed: false)
		cmds << zwave.protectionV1.protectionSet(protectionState: 1)
		cmds << zwave.protectionV1.protectionGet()
		log.trace "Executing 'lock' : $cmds" 
		secureSequence(cmds)
	}

	def unlock() {
		def cmds = []
		sendEvent(name: "unlock", value: "unlocked", displayed: false)
		cmds << zwave.protectionV1.protectionSet(protectionState: 0)
		cmds << zwave.protectionV1.protectionGet()
		log.trace "Executing 'unlock' : $cmds" 
		secureSequence (cmds)
	}

	def setLevel() {
		log.debug "Executing 'setLevel'"
		def nextValveSet = number

		sendEvent(name:"nextValveSetpoint", value: nextValveSet, descriptionText: "Next valve setpoint : ${nextValveSet}", displayed: true, isStateChange:false)
		
		cmds << zwave.switchMultilevelV3.switchMultilevelSet(value: nextValveSet)
		cmds << zwave.switchMultilevelV3.switchMultilevelGet()
				
		log.info "Executing 'setLevel' : $cmds"
		secureSequence(cmds)
	}

	def setHeatingSetpoint(Double degrees) {
		def cmds = []
		def precision = state.precision ?: 2
		def deviceScale = state.scale ?: 0
		
		sendEvent(name:"nextHeatingSetpoint", value: degrees, unit: getTemperatureScale(), descriptionText: "Next heating setpoint : ${degrees}", displayed: true, isStateChange:true)
		
		cmds << zwave.thermostatSetpointV2.thermostatSetpointSet(precision: precision, scale: deviceScale, scaledValue: degrees, setpointType: 1)
		cmds << zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 1)
				
		log.trace "Executing 'setHeatingSetpoint' : Setting Temp to ${degrees},  $cmds"
		secureSequence(cmds)
	}
def temperatureUp() {
    //log.debug(device.currentValue("nextHeatingSetpoint").toBigDecimal())
	def nextTemp = device.currentValue("nextHeatingSetpoint").toBigDecimal() + 0.5
							// TODO: deal with Farenheit?
	if(nextTemp > 28) {		// It can't handle above 28, so don't allow it go above
		nextTemp = 28
	}
	sendEvent(name:"nextHeatingSetpoint", value: nextTemp, unit: getTemperatureScale(), displayed: false)	
    runIn (5, "buffSetpoint",[data: [value: nextTemp], overwrite: true])
}
def temperatureDown() {
	def nextTemp = device.currentValue("nextHeatingSetpoint").toBigDecimal() - 0.5
	if(nextTemp < 8) {		// It can't go below 8, so don't allow it
		nextTemp = 8
	}
	sendEvent(name:"nextHeatingSetpoint", value: nextTemp, unit: getTemperatureScale(), displayed: false)	
   	runIn (5, "buffSetpoint",[data: [value: nextTemp], overwrite: true])
}
def buffSetpoint(data) {
	def key = "value"
	def nextTemp = data[key]
    //log.debug " buff nextTemp is $nextTemp"
	setHeatingSetpoint(nextTemp)
}
	def frost() {
		log.trace "frost to off"
		off()
	}

	def off() {
		def cmds = []
		sendEvent(name: "off", value: "frost", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 0)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "Executing 'off' : Frost On : $cmds"
		secureSequence(cmds)
	}

	def heat() {
		def cmds = []
		sendEvent(name: "thermostatMode", value: "heat", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 1)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "heat $cmds" 
		secureSequence (cmds)
	}

	def emergencyHeat() {
		log.trace "emergencyHeat to boost"
		boost()
	}

	def cool() {
		log.trace "cool to ecoheat"
		ecoheat()
	}

	def boost() {
		def cmds = []
		sendEvent(name: "thermostatMode", value: "boost", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 0x0F)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "Boost On $cmds"
		secureSequence(cmds)
	}

	def boostoff() {
		log.trace "Boost Off"
		heat()
	}

	def auto(){
		def cmds = []
		sendEvent(name: "directvalvecontrol", value: "dvcon", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 31)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "Executing 'auto' : DVC On : $cmds"
		secureSequence(cmds)
	}

	def ecoheat() {
		def cmds = []
		sendEvent(name: "thermostatMode", value: "eco", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 11)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "Eco : $cmds"
		secureSequence(cmds)
	}

	def ecooff() {
		log.trace "ecooff to heat"
		heat()
	}
	/*def dvcon(){
		def cmds = []
		sendEvent(name: "directvalvecontrol", value: "dvcon", displayed: true)
		cmds << zwave.thermostatModeV2.thermostatModeSet(mode: 31)
		cmds << zwave.thermostatModeV2.thermostatModeGet()
		log.trace "DVC On $cmds"
		secureSequence(cmds)
	}
	def dvcoff() {
		log.trace "DVC Off"
		secureSequence(cmds)
		heat()
	}*/
	def setThermostatMode() {
		if (mode == "on" || mode == "heat" || mode == "1") { heat()}
		if (mode == "off" || mode == "0" || mode == "15") { off()}
		if (mode == "eco" || mode == "cool" || mode == "11") { ecoheat()}
		if (mode == "auto" || mode == "31") { dvc()}
		if (mode == "boost" || "emergency heat") {boost()}
		log."Executing 'setThermostatMode' : $mode"
	}
	def refresh() {
		log.trace "refresh"
		poll()
	}

def setDeviceLimits() { // for google and amazon compatability
	sendEvent(name:"minHeatingSetpoint", value: settings.tempMin ?: 8, unit: "°C", displayed: false)
	sendEvent(name:"maxHeatingSetpoint", value: settings.tempMax ?: 28, unit: "°C", displayed: false)
	log.trace "setDeviceLimits - device max/min set"
}	

	
def updated() {
sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
    if (!state.updatedLastRanAt || new Date().time >= state.updatedLastRanAt + 2000) {
        state.updatedLastRanAt = new Date().time
        unschedule(refresh)
        unschedule(poll)
        log.trace "updated 1"
        runIn (05, configure)
        sendEvent(name: "configure", value: "configdue", displayed: false)
        switch(refreshRate) {
		case "1":
			runEvery1Minute(poll)
			log.info "Refresh Scheduled for every minute"
			break
		case "15":
			runEvery15Minutes(poll)
			log.info "Refresh Scheduled for every 15 minutes"
			break
		case "10":
			runEvery10Minutes(poll)
			log.info "Refresh Scheduled for every 10 minutes"
			break
		case "5":
        	runEvery5Minutes(poll)
			log.info "Refresh Scheduled for every 5 minutes"
            break
        case "0":
			log.info "Refresh off"}
 
	}
    else {
    	log.warn "update ran within the last 2 seconds"
    }
}
	def poll() { // If you add the Polling capability to your device type, this command will be called approximately every 5 minutes to check the device's state
	//log.debug "poll"
		def cmds = []

		if (!state.lastBatteryReportReceivedAt || (new Date().time) - state.lastBatteryReportReceivedAt > daysToTime(1)) {
			log.trace "POLL - Asking for battery report as over 1 days since"
			cmds << zwave.batteryV1.batteryGet()
		}
		//once an hour ask for everything
		if (!state.extra || (new Date().time) - state.extra > (60*60000)) {			// mimutes * millseconds these settings shouldnt be needs as device should send response at time of update
			//cmds <<	zwave.thermostatModeV2.thermostatModeGet()							// get mode
			cmds <<	zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 11) 	// get eco/cool setpoint
			cmds <<	zwave.basicV1.basicGet()											// get mode (basic)	
			cmds <<	zwave.thermostatSetpointV2.thermostatSetpointGet(setpointType: 1)	// get heating setpoint
			state.extra = new Date().time
		}
		cmds <<	zwave.sensorMultilevelV1.sensorMultilevelGet()	// get temp
		cmds << zwave.switchMultilevelV3.switchMultilevelGet()	// valve position
		cmds <<	zwave.thermostatModeV1.thermostatModeGet()		// get mode
		
		log.trace "POLL $cmds"
		secureSequence (cmds)
	}

def daysToTime(days) {
		days*24*60*60*1000
}
def configure() {
	state.supportedModes = [off,heat] // basic modes prior to details from device
	setDeviceLimits()
    //log.debug "tempReport : $tempReport"
    //log.debug "valveReport : $valveReport"
    log.debug "refreshRate : $refreshRate"
	def cmds = []
	cmds << zwave.configurationV1.configurationSet(configurationValue:  LCDinvert == "Yes" ? [0x01] : [0x00], parameterNumber:1, size:1, scaledConfigurationValue:  LCDinvert == "Yes" ? 0x01 : 0x00)//,
	cmds << zwave.configurationV1.configurationSet(configurationValue: LCDtimeout == null ? [0] : [LCDtimeout], parameterNumber:2, size:1, scaledConfigurationValue: LCDtimeout == null ? 0 :  LCDtimeout)//,
	cmds << zwave.configurationV1.configurationSet(configurationValue:  backlight == "Yes" ? [0x01] : [0x00], parameterNumber:3, size:1, scaledConfigurationValue:  backlight == "Yes" ? 0x01 : 0x00)//,
	cmds << zwave.configurationV1.configurationSet(configurationValue:  battNotification == "Event only" ? [0x00] : [0x01], parameterNumber:4, size:1, scaledConfigurationValue:  battNotification == "Event only" ? 0x00 : 0x01) //,
	cmds << zwave.configurationV1.configurationSet(configurationValue:  tempReport == "1" ? [0x01] : tempReport == "2" ? [0x02] : tempReport == "5" ? [0x05] : tempReport == "8" ? [0x08] : tempReport == "10" ? [0x0A] : tempReport == "15" ? [0x0F] : tempReport == "20" ? [0x14] : tempReport == "30" ? [0x1E] : tempReport == "50" ? [0x32] : [0x00], parameterNumber:5, size:1, scaledConfigurationValue:  tempReport == "1" ? 0x01 : tempReport == "2" ? 0x02 : tempReport == "5" ? 0x05 : tempReport == "8" ? 0x08 : tempReport == "10" ? 0x0A : tempReport == "15" ? 0x0E : tempReport == "20" ? 0x14 : tempReport == "30" ? 0x1E : tempReport == "50" ? 0x32 : 0x00)//,
	cmds << zwave.configurationV1.configurationSet(configurationValue:  valveReport == "1" ? [0x01] : valveReport == "5" ? [0x05] : valveReport == "10" ? [0x0A] : valveReport == "20" ? [0x14] : valveReport == "30" ? [0x1E] : valveReport == "50" ? [0x32] : [0x00], parameterNumber:6, size:1, scaledConfigurationValue:  valveReport == "1" ? 0x01 : valveReport == "5" ? 0x05 : valveReport == "10" ? 0x0A : valveReport == "20" ? 0x14 : valveReport == "30" ? 0x1E : valveReport == "50" ? 0x32 : 0x00)//,
	cmds << zwave.configurationV1.configurationSet(configurationValue:  windowOpen == "Disabled" ? [0x00] : windowOpen == "Low" ? [0x01] : windowOpen == "High" ? [0x03] : [0x02], parameterNumber:7, size:1, scaledConfigurationValue: windowOpen == "Disabled" ? 0x00 : windowOpen == "Low" ? 0x01 : windowOpen == "High" ? 0x03 : 0x02)//,	
	cmds << zwave.configurationV1.configurationSet(configurationValue: tempOffset == null ? [0] : [tempOffset*10], parameterNumber:8, size:1, scaledConfigurationValue: tempOffset == null ? 0 : tempOffset*10)//,
	cmds << zwave.thermostatSetpointV1.thermostatSetpointSet(precision: 1, reserved01: 0, scale: 0, scaledValue: ecoTemp == null ? 18 : ecoTemp, setpointType: 11, size: 2, value: ecoTemp == null ? [0, 180] : [0, ecoTemp*10])//,
	cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType:1, scale:1)  // get temp
	cmds << zwave.thermostatModeV2.thermostatModeGet()
	cmds << zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 0x01)
	cmds << zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 0x0B)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:1)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:2)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:3)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:4)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:5)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:6)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:7)
	cmds << zwave.configurationV1.configurationGet(parameterNumber:8)
	cmds << zwave.batteryV1.batteryGet()
	cmds << zwave.thermostatModeV2.thermostatModeSupportedGet()
	cmds << zwave.manufacturerSpecificV1.manufacturerSpecificGet()
	sendEvent(name: "configure", value: "Configuration sent", displayed: false)   
	log.trace "Configuration sent"
	secureSequence(cmds)
	}

def secure(physicalgraph.zwave.Command cmd) {
	if (state.sec) {
		//log.debug "Seq secure - $cmd"
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} 
    else {
    	//log.debug "Seq unsecure- $cmd"
		cmd.format()
	}
}


	def secureSequence(commands, delay=1500) {
	//log.debug "SeSeq $commands"
		sendHubCommand(commands.collect{ response(secure(it)) }, delay)
	}	
																					def zwaveEvent(physicalgraph.zwave.commands.crc16encapv1.Crc16Encap cmd) { //dont know if this is used
	log.debug "crc16encap- $cmd"
	def versions = [0x31: 5, 0x30: 1, 0x9C: 1, 0x70: 2, 0x85: 2]
	def version = versions[cmd.commandClass as Integer]
	def ccObj = version ? zwave.commandClass(cmd.commandClass, version) : zwave.commandClass(cmd.commandClass)
	def encapsulatedCommand = ccObj?.command(cmd.command)?.parse(cmd.data)
	if (encapsulatedCommand) {
		zwaveEvent(encapsulatedCommand)
	}
}



